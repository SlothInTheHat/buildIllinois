[5:20:57 AM] so after what I can understand all I have to do for this problem is create an algorithm that giving us sort of array of distinct integers and the target value and just Returns the index and if it doesn't exist then I have to return the index of where would be in this order over there I'm thinking for this out for this problem I could just use a simple binary search the only sort of difference of the regular binary search would have versus this problem was that if the index if the element doesn't exist and I still have to return an index instead of negative one so that's basically the only edit I'll have to make and from there I think everything is straightforwards
[5:21:14 AM]  numb like this 104 which is or 10 to the 4 sorry which is fine because this algorithm should run an unlock n so much less than the 10 ^ 8 limit and yeah
[5:22:35 AM] yeah so for implementing binary search I think I'm going to have sort of a low pointer and a high pointer and I'm just going to repeatedly calculate the midpoint and then based off of and so the lowest can be set initially to zero and the highest initially going to be set to the maximum the last element of the array did not last maximum index and I'm going to just repeatedly calculate the midpoint and if the number or if the element is greater
[5:22:38 AM]  in the actual Target then I'm going to move
[5:22:52 AM]  the high balance to the middle minus one and if the otherwise I'm going to move the load balance to the middle plus one and I'm just going to repeat there as for handling the case for the target's not found
[5:23:05 AM]  this binary search is still find where it's supposed to be and so instead of just returning negative one if the low Bond becomes greater than the right balance I'll just return
[5:23:08 AM]  but they agreed on
[5:26:58 AM] so I just quoted my thoughts I ended up not using a binary search I just did a linear thing and it still should pass 10 to the four given that
[5:27:01 AM]  just a bedtime so living your time
